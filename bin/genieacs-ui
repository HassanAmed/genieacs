#!/usr/bin/env -S node -r esm -r ts-node/register/transpile-only


/**
#####################################    File Description    #######################################

This file is an executable file to run ui-server. Mainly this files imports all other small compo-
nents from code files in lib and runs server. Mainly the tasks it performs are in this order
- Start logger (for logging any activity)
- Get configurations for ui
- Implementations of functions to stop service on stop signals (SIGINT & SIGTERM)
- Clustering
- Import ui listener start server.

####################################################################################################
 */

import * as config from "../lib/config";
import * as logger from "../lib/logger";
import * as cluster from "../lib/cluster";
import * as server from "../lib/server";
import { listener } from "../lib/ui";
import * as extensions from "../lib/extensions";
import * as db from "../lib/ui/db";
import * as db2 from "../lib/db";
import * as cache from "../lib/cache";
import { version as VERSION } from "../package.json";
/** Initialize logging for ui service */
logger.init("ui", VERSION);
/**
 * @description Get Url address & port for UI service from configurations
 */
const SERVICE_ADDRESS = config.get("UI_INTERFACE");
const SERVICE_PORT = config.get("UI_PORT");
/**
 * @description Disconnect connections from db 
 * Kill all process &
 * Disconnect from childprocesses cluster and stop service
 */
function exitWorkerGracefully(): void {
  setTimeout(exitWorkerUngracefully, 5000).unref();
  Promise.all([
    db.disconnect(),
    db2.disconnect(),
    cache.disconnect(),
    extensions.killAll(),
    cluster.worker.disconnect()
  ]).catch(exitWorkerUngracefully);
}
/**
 * @description Kill All connections forcefully
 */
function exitWorkerUngracefully(): void {
  extensions.killAll().then(() => {
    process.exit(1);
  });
}

if (!cluster.worker) {
  //Get count of child processes
  const WORKER_COUNT = config.get("UI_WORKER_PROCESSES");

  logger.info({
    message: `genieacs-ui starting`,
    pid: process.pid,
    version: VERSION
  });
/**
 * Start Cluster (Node. js runs single threaded programming
 * which is very memory efficient, but to take advantage of
 * computers multi-core systems, the Cluster module allows you to easily
 * create child processes that each runs on their own single thread, to handle the load.)
 */
  cluster.start(WORKER_COUNT, SERVICE_PORT, SERVICE_ADDRESS);

  process.on("SIGINT", () => {
    logger.info({
      message: "Received signal SIGINT, exiting",
      pid: process.pid
    });
/**
 * @description Stop cluster on recieving exit signal
 * SIGTERM:This signal terminates a process immediately.
 * This can also be handled ,ignored.This is also used for graceful termination of a process.
 * The only difference is that It is generated by shell command kill by default.
 */
    cluster.stop();
  });

  process.on("SIGTERM", () => {
    logger.info({
      message: "Received signal SIGTERM, exiting",
      pid: process.pid
    });

    cluster.stop();
  });
} else {
  const ssl = {
    key: config.get("UI_SSL_KEY"),
    cert: config.get("UI_SSL_CERT")
  };

  let stopping = false;

  process.on("uncaughtException", err => {
    if ((err as NodeJS.ErrnoException).code === "ERR_IPC_DISCONNECTED") return;
    logger.error({
      message: "Uncaught exception",
      exception: err,
      pid: process.pid
    });
    stopping = true;
    server
      .stop()
      .then(exitWorkerGracefully)
      .catch(exitWorkerUngracefully);
  });

  const _listener = (req, res): void => {
    if (stopping) res.setHeader("Connection", "close");
    listener(req, res);
  };
// Connect DB & Caching and start UI service (server)
/**
 * initPromise = Promise returned after all connections made server started
 */
  const initPromise = Promise.all([db2.connect(), cache.connect()])
    .then(() => {
      server.start(SERVICE_PORT, SERVICE_ADDRESS, ssl, _listener);
    })
    .catch(err => {
      setTimeout(() => {
        throw err;
      });
    });
/**
 * SIGINT: This signal interrupts a process immediately.
 * The default action of this signal is to terminate a process gracefully .
 * It can be handled , ignored or caught .It can be sent from a terminal as input characters.
 * This signal is generated when a user presses Ctrl+C.
 */
  process.on("SIGINT", () => {
    stopping = true;
    initPromise.finally(() => {
      server
        .stop()
        .then(exitWorkerGracefully)
        .catch(exitWorkerUngracefully);
    });
  });

  process.on("SIGTERM", () => {
    stopping = true;
    initPromise.finally(() => {
      server
        .stop()
        .then(exitWorkerGracefully)
        .catch(exitWorkerUngracefully);
    });
  });
}
