#!/usr/bin/env -S node -r esm -r ts-node/register/transpile-only

/**
#####################################    File Description    #######################################

This file is an executable file to run file-server. Mainly this files imports all other small compo-
nents from code files in lib and runs server. Main purpose of this server is just to provide ftp for
CPEs to download files. These files can be firmware images, upgrades etc.
- Start logger (for logging any activity)
- Get configurations(port and host) for fs(filserver)
- Implementations of functions to stop service on stop signals (SIGINT & SIGTERM)
- Clustering
- Import fs listener and start server.

####################################################################################################
 */

import * as config from "../lib/config";
import * as logger from "../lib/logger";
import * as cluster from "../lib/cluster";
import * as server from "../lib/server";
import { listener } from "../lib/fs";
import * as db from "../lib/db";
import * as cache from "../lib/cache";
import { version as VERSION } from "../package.json";
/** Initialize logging for file server service */
logger.init("fs", VERSION);
/**
 * @description Get Url address & port for fs service from configurations
 */
const SERVICE_ADDRESS = config.get("FS_INTERFACE");
const SERVICE_PORT = config.get("FS_PORT");
/**
 * @description Disconnect connections from db 
 * Kill all process &
 * Disconnect from childprocesses cluster
 */
function exitWorkerGracefully(): void {
  setTimeout(exitWorkerUngracefully, 5000).unref();
  Promise.all([
    db.disconnect(),
    cache.disconnect(),
    cluster.worker.disconnect()
  ]).catch(exitWorkerUngracefully);
}
/**
 * @description Kill All connections forcefully
 */
function exitWorkerUngracefully(): void {
  process.exit(1);
}

if (!cluster.worker) {
  //Get count of child processes
  const WORKER_COUNT = config.get("FS_WORKER_PROCESSES");

  logger.info({
    message: `genieacs-fs starting`,
    pid: process.pid,
    version: VERSION
  });
/**
 * @description  Start Cluster (Node. js runs single threaded programming
 * which is very memory efficient, but to take advantage of
 * computers multi-core systems, the Cluster module allows you to easily
 * create child processes that each runs on their own single thread, to handle the load.)
 */
  cluster.start(WORKER_COUNT, SERVICE_PORT, SERVICE_ADDRESS);

  process.on("SIGINT", () => {
    logger.info({
      message: "Received signal SIGINT, exiting",
      pid: process.pid
    });
/**
 * @description Stop cluster on recieving exit signal
 * SIGTERM:This signal terminates a process immediately.
 * This can also be handled ,ignored.This is also used for graceful termination of a process.
 * The only difference is that It is generated by shell command kill by default.
 */
    cluster.stop();
  });

  process.on("SIGTERM", () => {
    logger.info({
      message: "Received signal SIGTERM, exiting",
      pid: process.pid
    });

    cluster.stop();
  });
} else {
  const ssl = {
    key: config.get("FS_SSL_KEY"),
    cert: config.get("FS_SSL_CERT")
  };

  let stopping = false;

  process.on("uncaughtException", err => {
    if ((err as NodeJS.ErrnoException).code === "ERR_IPC_DISCONNECTED") return;
    logger.error({
      message: "Uncaught exception",
      exception: err,
      pid: process.pid
    });
    stopping = true;
    server
      .stop()
      .then(exitWorkerGracefully)
      .catch(exitWorkerUngracefully);
  });

  const _listener = (req, res): void => {
    if (stopping) res.setHeader("Connection", "close");
    listener(req, res);
  };
// Connect DB & Caching and start fs service (server)
/**
 * initPromise = Promise returned after all connections made server started
 */
  const initPromise = Promise.all([db.connect(), cache.connect()])
    .then(() => {
      server.start(SERVICE_PORT, SERVICE_ADDRESS, ssl, _listener);
    })
    .catch(err => {
      setTimeout(() => {
        throw err;
      });
    });
/**
 * SIGINT: This signal interrupts a process immediately.
 * The default action of this signal is to terminate a process gracefully .
 * It can be handled , ignored or caught .It can be sent from a terminal as input characters.
 * This signal is generated when a user presses Ctrl+C.
 */
  process.on("SIGINT", () => {
    stopping = true;
    initPromise.finally(() => {
      server
        .stop()
        .then(exitWorkerGracefully)
        .catch(exitWorkerUngracefully);
    });
  });

  process.on("SIGTERM", () => {
    stopping = true;
    initPromise.finally(() => {
      server
        .stop()
        .then(exitWorkerGracefully)
        .catch(exitWorkerUngracefully);
    });
  });
}
